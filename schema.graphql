schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

union LocationResult = District | Region | Street | Ward

union UserProfile = Admin | Landlord | Tenant

type Address {
  coordinates: Coordinates
  district: String!
  postalCode: String
  region: String!
  street: String!
  ward: String!
}

type Admin {
  accountStatus: AccountStatus
  createdAt: AWSDateTime
  currency: String
  email: String!
  emailNotifications: Boolean
  firstName: String!
  isEmailVerified: Boolean
  language: String
  lastName: String!
  permissions: [String!]
  phoneNumber: String
  profileImage: String
  pushNotifications: Boolean
  smsNotifications: Boolean
  updatedAt: AWSDateTime
  userId: ID!
  userType: UserType!
}

type AppInitialState {
  categorizedProperties: CategorizedPropertiesResponse!
  totalProperties: Int!
}

type ApplicantDetails {
  emergencyContact: EmergencyContact!
  employmentStatus: EmploymentStatus!
  hasPets: Boolean!
  leaseDuration: Int!
  monthlyIncome: Float!
  moveInDate: AWSDateTime!
  numberOfOccupants: Int!
  occupation: String!
  petDetails: String
  smokingStatus: SmokingStatus!
}

type Application {
  applicant: Tenant
  applicantDetails: ApplicantDetails!
  applicantUserId: ID!
  applicationId: ID!
  createdAt: AWSDateTime!
  documents: ApplicationDocuments
  employment: EmploymentDetails
  landlord: Landlord
  landlordId: ID!
  landlordNotes: String
  property: Property
  propertyId: ID!
  references: [Reference!]
  rejectionReason: String
  reviewedAt: AWSDateTime
  reviewedBy: ID
  status: ApplicationStatus!
  submittedAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ApplicationDocuments {
  additionalDocuments: [String!]
  bankStatements: [String!]
  employmentLetter: String
  identificationDocument: String
  previousLandlordReference: String
  proofOfIncome: [String!]
}

type ApplicationListResponse {
  applications: [Application!]!
  count: Int!
  nextToken: String
}

type ApplicationResponse {
  applicationId: ID
  message: String!
  status: String
  submittedAt: String
  success: Boolean!
}

type ApplicationStats {
  approved: Int!
  rejected: Int!
  submitted: Int!
  total: Int!
  underReview: Int!
  withdrawn: Int!
}

type AuthResponse {
  accessToken: String!
  refreshToken: String!
  user: UserProfile!
}

type CategorizedPropertiesResponse {
  favorites: CategoryPropertyResponse
  lowestPrice: CategoryPropertyResponse!
  more: CategoryPropertyResponse!
  mostViewed: CategoryPropertyResponse!
  nearby: CategoryPropertyResponse!
  recentlyViewed: CategoryPropertyResponse
}

type CategoryPropertyResponse {
  category: PropertyCategory!
  count: Int!
  nextToken: String
  properties: [PropertyCard!]!
}

type ChatMessage {
  content: String!
  conversationId: String!
  id: ID!
  isRead: Boolean!
  senderId: String!
  timestamp: String!
}

type Conversation {
  createdAt: String!
  id: String!
  landlordId: String!
  lastMessage: String!
  lastMessageSender: String!
  lastMessageTime: String!
  propertyId: String!
  propertyTitle: String!
  tenantId: String!
  unreadCount: AWSJSON!
  updatedAt: String!
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

type District {
  id: ID!
  name: String!
  regionId: ID!
}

type EmergencyContact {
  email: String
  name: String!
  phoneNumber: String!
  relationship: String!
}

type EmploymentDetails {
  employerAddress: String!
  employerName: String!
  employerPhone: String!
  employmentStartDate: AWSDateTime!
  jobTitle: String!
  monthlyIncome: Float!
}

type FavoriteResponse {
  isFavorited: Boolean!
  message: String
  success: Boolean!
}

type Landlord {
  accountStatus: AccountStatus
  businessLicense: String
  businessName: String
  createdAt: AWSDateTime
  currency: String
  email: String!
  emailNotifications: Boolean
  firstName: String!
  isEmailVerified: Boolean
  language: String
  lastName: String!
  phoneNumber: String
  profileImage: String
  pushNotifications: Boolean
  smsNotifications: Boolean
  taxId: String
  updatedAt: AWSDateTime
  userId: ID!
  userType: UserType!
  verificationDocuments: [String!]
}

type LocationCreateResponse {
  location: LocationResult!
  message: String!
  success: Boolean!
}

type LocationImportResponse {
  errors: [String!]
  imported: Int!
  message: String!
  skipped: Int!
  success: Boolean!
}

type LocationJsonResponse {
  cloudfrontUrl: String!
  message: String!
  success: Boolean!
}

type LocationUpdateResponse {
  location: Region
  message: String
  success: Boolean!
}

type MediaFile {
  contentType: String!
  fileName: String
  fileUrl: String!
}

type MediaItem {
  actionTime: Float!
  additionalFiles: [MediaFile]
  media: PropertyMedia
  userId: String!
}

type MediaUploadResponse {
  fileUrl: String!
  key: String!
  uploadUrl: String!
}

type Mutation {
  approveApplication(applicationId: ID!, landlordNotes: String): Application!
  assignPropertyManager(landlordId: ID!, managerId: ID!, propertyId: ID!): SuccessResponse!
  associateMediaWithProperty(landlordId: ID!, media: PropertyMediaInput!, propertyId: ID!): Property!
  becomeLandlord(input: BecomeLandlordInput!, userId: ID!): ApplicationResponse!
  createConversation(input: CreateConversationInput!): Conversation!
  createLocation(input: CreateLocationInput!): LocationCreateResponse!
  createProperty(input: CreatePropertyInput!, landlordId: ID!): Property!
  deleteMediaItem(fileUrl: String!, userId: ID!): MediaItem
  deleteProperty(landlordId: ID!, propertyId: ID!): SuccessResponse!
  dummyMutation: String
  forgotPassword(email: String!): SuccessResponse!
  getMediaUploadUrl(contentType: String!, fileName: String!, userId: ID!): MediaUploadResponse!
  importLocationsFromCSV(csvData: String!): LocationImportResponse!
  importPropertiesFromCSV(csvData: String!): PropertyImportResult!
  markAsRead(conversationId: String!, userId: String!): Conversation!
  markPropertyAsAvailable(landlordId: ID!, propertyId: ID!): Property!
  markPropertyAsRented(landlordId: ID!, propertyId: ID!, tenantId: ID!): Property!
  publishConversationUpdate(input: AWSJSON!): PublishResult
  publishNewMessage(input: AWSJSON!): PublishResult
  publishNewPropertyEvent(propertyId: ID!, region: String!): SubscriptionPublishResponse
  publishPropertyUpdateEvent(input: PropertyUpdateEventInput!): PropertyUpdateEvent
  publishUnreadCountUpdate(input: AWSJSON!): PublishResult
  regenerateLocationJson: LocationJsonResponse!
  rejectApplication(applicationId: ID!, landlordNotes: String, rejectionReason: String!): Application!
  removePropertyManager(landlordId: ID!, propertyId: ID!): SuccessResponse!
  resendVerificationCode(email: String!): SuccessResponse!
  resetPassword(confirmationCode: String!, email: String!, newPassword: String!): SuccessResponse!
  reviewApplication(applicationId: ID!, input: ReviewApplicationInput!): Application!
  reviewLandlordApplication(applicationId: ID!, input: ReviewApplicationInput!): SuccessResponse!
  sendMessage(input: SendMessageInput!): ChatMessage!
  signIn(email: String!, password: String!): AuthResponse!
  signUp(input: SignUpInput!): AuthResponse!
  submitApplication(input: SubmitApplicationInput!): Application!
  submitLandlordApplication(input: LandlordApplicationInput!): ApplicationResponse!
  toggleFavorite(propertyId: ID!, userId: ID!): FavoriteResponse!
  updateApplication(applicationId: ID!, input: UpdateApplicationInput!): Application!
  updateLocation(locationId: ID!, name: String!): LocationUpdateResponse!
  updateProperty(input: UpdatePropertyInput!, landlordId: ID!, propertyId: ID!): Property!
  updatePropertyStatus(landlordId: ID!, propertyId: ID!, status: PropertyStatus!): Property!
  updateUser(input: UpdateUserInput!, userId: ID!): UserProfile!
  verifyEmail(code: String!, email: String!): SuccessResponse!
  withdrawApplication(applicationId: ID!): Application!
}

type PersonalizedSections {
  favorites: [PropertyCard!]
  recentlyViewed: [PropertyCard!]
  recommended: [PropertyCard!]
}

type Property {
  address: Address!
  amenities: [String!]
  availability: PropertyAvailability!
  createdAt: AWSDateTime!
  description: String!
  landlordId: ID!
  managerId: ID
  media: PropertyMedia
  pricing: PropertyPricing!
  propertyId: ID!
  propertyType: PropertyType!
  specifications: PropertySpecifications!
  status: PropertyStatus!
  title: String!
  updatedAt: AWSDateTime!
  version: Int
}

type PropertyAvailability {
  available: Boolean!
  availableFrom: AWSDateTime
  maximumLeaseTerm: Int
  minimumLeaseTerm: Int
}

type PropertyCard {
  available: Boolean!
  bedrooms: Int
  category: PropertyCategory
  currency: String!
  district: String!
  monthlyRent: Float!
  propertyId: ID!
  propertyType: PropertyType!
  region: String!
  thumbnail: String
  title: String!
}

type PropertyCardsResponse {
  count: Int!
  nextToken: String
  properties: [PropertyCard!]!
}

type PropertyChange {
  field: String!
  newValue: String!
  oldValue: String
}

type PropertyImportResult {
  errors: [String!]!
  imported: Int!
  message: String!
  skipped: Int!
  success: Boolean!
  updated: Int!
}

type PropertyListResponse {
  count: Int!
  nextToken: String
  properties: [Property!]!
}

type PropertyMedia {
  floorPlan: String
  images: [String!]
  videos: [String!]
  virtualTour: String
}

type PropertyPricing {
  currency: String!
  deposit: Float!
  monthlyRent: Float!
  serviceCharge: Float
  utilitiesIncluded: Boolean
}

type PropertySearchResponse {
  count: Int!
  from: Int!
  nextToken: String
  properties: [Property!]!
  size: Int!
  total: Int!
}

type PropertySpecifications {
  bathrooms: Int
  bedrooms: Int
  floors: Int
  furnished: Boolean
  parkingSpaces: Int
  squareMeters: Float!
}

type PropertyUpdateEvent {
  changes: [PropertyChange!]
  eventType: PropertyEventType!
  property: Property
  propertyId: ID!
  timestamp: AWSDateTime!
}

type PublishResult {
  message: String
  success: Boolean!
}

type Query {
  dummyQuery: String
  getAppInitialState(limitPerCategory: Int, userId: ID): AppInitialState!
  getApplication(applicationId: ID!): Application
  getApplicationDocumentUploadUrl(applicationId: ID!, fileName: String!, fileType: String!): MediaUploadResponse!
  getApplicationStats(landlordId: ID!): ApplicationStats!
  getCategorizedProperties(limitPerCategory: Int, userId: ID): CategorizedPropertiesResponse!
  getConversationMessages(conversationId: String!): [ChatMessage!]!
  getDistricts(regionId: ID!): [District!]!
  getMediaLibrary(userId: ID!): MediaItem
  getNearbyProperties(lat: Float!, lng: Float!, radiusKm: Float): [Property!]!
  getPropertiesByCategory(category: PropertyCategory!, limit: Int, nextToken: String, userId: ID): CategoryPropertyResponse!
  getPropertiesByLocation(district: String, region: String!): [Property!]!
  getProperty(propertyId: ID!, userId: ID): Property
  getPropertyCards(limit: Int, nextToken: String): PropertyCardsResponse!
  getRegions: [Region!]!
  getStreets(wardId: ID!): [Street!]!
  getUnreadCount(userId: String!): Int!
  getUser(userId: ID!): UserProfile
  getUserConversations(userId: String!): [Conversation!]!
  getWards(districtId: ID!): [Ward!]!
  listLandlordApplications(landlordId: ID!, limit: Int, nextToken: String, status: ApplicationStatus): ApplicationListResponse!
  listLandlordProperties(landlordId: ID!, limit: Int, nextToken: String): PropertyListResponse!
  listManagedProperties(limit: Int, managerId: ID!, nextToken: String): PropertyListResponse!
  listMyApplications(limit: Int, nextToken: String, status: ApplicationStatus): ApplicationListResponse!
  listProperties(limit: Int, nextToken: String): PropertyListResponse!
  listPropertyApplications(limit: Int, nextToken: String, propertyId: ID!, status: ApplicationStatus): ApplicationListResponse!
  searchProperties(bedrooms: Int, district: String, from: Int, limit: Int, maxPrice: Float, minPrice: Float, propertyType: PropertyType, q: String, region: String): PropertySearchResponse!
}

type Reference {
  email: String
  name: String!
  phoneNumber: String!
  relationship: String!
}

type Region {
  id: ID!
  name: String!
}

type Street {
  id: ID!
  name: String!
  wardId: ID!
}

type Subscription {
  dummySubscription: String
  onApplicationStatusChanged(applicationId: ID!): Application
  onConversationUpdated(userId: String!): Conversation
  onNewApplicationForLandlord(landlordId: ID!): Application
  onNewMessage(conversationId: String!): ChatMessage
  onNewPropertyInRegion(region: String!): Property
  onNewPropertyMatchesSearch(searchCriteria: PropertySearchInput!): Property
  onPropertiesUpdated(propertyIds: [ID!]!): PropertyUpdateEvent
  onPropertyUpdated(propertyId: ID!): PropertyUpdateEvent
  onUnreadCountChanged(userId: String!): UnreadCountUpdate
}

type SubscriptionPublishResponse {
  message: String
  propertyId: ID
  success: Boolean!
}

type SuccessResponse {
  message: String!
  success: Boolean!
}

type Tenant {
  accountStatus: AccountStatus
  createdAt: AWSDateTime
  currency: String
  email: String!
  emailNotifications: Boolean
  firstName: String!
  isEmailVerified: Boolean
  language: String
  lastName: String!
  phoneNumber: String
  profileImage: String
  pushNotifications: Boolean
  smsNotifications: Boolean
  updatedAt: AWSDateTime
  userId: ID!
  userType: UserType!
}

type UnreadCountUpdate {
  totalUnread: Int!
}

type UserBasic {
  currency: String!
  email: String!
  firstName: String!
  language: String!
  lastName: String!
  profileImage: String
  userId: ID!
  userType: UserType!
}

type Ward {
  districtId: ID!
  id: ID!
  name: String!
}

enum AccountStatus {
  ACTIVE
  PENDING_LANDLORD_VERIFICATION
  PENDING_VERIFICATION
  SUSPENDED
}

enum ApplicationStatus {
  APPROVED
  EXPIRED
  REJECTED
  SUBMITTED
  UNDER_REVIEW
  WITHDRAWN
}

enum EmploymentStatus {
  CONTRACT
  EMPLOYED_FULL_TIME
  EMPLOYED_PART_TIME
  RETIRED
  SELF_EMPLOYED
  STUDENT
  UNEMPLOYED
}

enum LocationType {
  DISTRICT
  REGION
  STREET
  WARD
}

enum PropertyCategory {
  FAVORITES
  LOWEST_PRICE
  MORE
  MOST_VIEWED
  NEARBY
  RECENTLY_VIEWED
}

enum PropertyEventType {
  AVAILABILITY_CHANGED
  DESCRIPTION_UPDATED
  MEDIA_UPDATED
  PRICE_CHANGED
  PROPERTY_CREATED
  STATUS_CHANGED
}

enum PropertyStatus {
  AVAILABLE
  DELETED
  DRAFT
  MAINTENANCE
  RENTED
}

enum PropertyType {
  APARTMENT
  COMMERCIAL
  HOUSE
  LAND
  ROOM
  STUDIO
}

enum SmokingStatus {
  NON_SMOKER
  OCCASIONAL
  SMOKER
}

enum UserType {
  ADMIN
  LANDLORD
  TENANT
}

input AddressInput {
  coordinates: CoordinatesInput
  district: String!
  postalCode: String
  region: String!
  street: String!
  ward: String!
}

input ApplicantDetailsInput {
  emergencyContact: EmergencyContactInput!
  employmentStatus: EmploymentStatus!
  hasPets: Boolean!
  leaseDuration: Int!
  monthlyIncome: Float!
  moveInDate: AWSDateTime!
  numberOfOccupants: Int!
  occupation: String!
  petDetails: String
  smokingStatus: SmokingStatus!
}

input ApplicationDocumentsInput {
  additionalDocuments: [String!]
  bankStatements: [String!]
  employmentLetter: String
  identificationDocument: String
  previousLandlordReference: String
  proofOfIncome: [String!]
}

input BecomeLandlordInput {
  businessLicense: String!
  businessName: String!
  taxId: String!
  verificationDocuments: [String!]
}

input CognitoUserPool {
  userPoolId: String!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

input CreateConversationInput {
  initialMessage: String
  landlordId: String!
  propertyId: String!
  propertyTitle: String!
  tenantId: String!
}

input CreateLocationInput {
  name: String!
  parent: String
  type: LocationType!
}

input CreatePropertyInput {
  address: AddressInput!
  amenities: [String!]
  availability: PropertyAvailabilityInput!
  description: String!
  media: PropertyMediaInput
  pricing: PropertyPricingInput!
  propertyType: PropertyType!
  specifications: PropertySpecificationsInput!
  title: String!
}

input EmergencyContactInput {
  email: String
  name: String!
  phoneNumber: String!
  relationship: String!
}

input EmploymentDetailsInput {
  employerAddress: String!
  employerName: String!
  employerPhone: String!
  employmentStartDate: AWSDateTime!
  jobTitle: String!
  monthlyIncome: Float!
}

input LandlordApplicationInput {
  address: AddressInput!
  alternatePhone: String
  birthDate: String!
  nationalId: String!
  phoneNumber: String!
  userId: ID!
}

input PropertyAvailabilityInput {
  available: Boolean!
  availableFrom: AWSDateTime
  maximumLeaseTerm: Int
  minimumLeaseTerm: Int
}

input PropertyChangeInput {
  field: String!
  newValue: String!
  oldValue: String
}

input PropertyMediaInput {
  floorPlan: String
  images: [String!]
  videos: [String!]
  virtualTour: String
}

input PropertyPricingInput {
  currency: String!
  deposit: Float!
  monthlyRent: Float!
  serviceCharge: Float
  utilitiesIncluded: Boolean
}

input PropertySearchInput {
  bedrooms: Int
  district: String
  maxPrice: Float
  minPrice: Float
  propertyType: PropertyType
  region: String
}

input PropertySpecificationsInput {
  bathrooms: Int
  bedrooms: Int
  floors: Int
  furnished: Boolean
  parkingSpaces: Int
  squareMeters: Float!
}

input PropertyUpdateEventInput {
  changes: [PropertyChangeInput!]
  eventType: PropertyEventType!
  propertyId: ID!
  timestamp: AWSDateTime!
}

input ReferenceInput {
  email: String
  name: String!
  phoneNumber: String!
  relationship: String!
}

input ReviewApplicationInput {
  landlordNotes: String
  rejectionReason: String
  status: ApplicationStatus!
}

input SendMessageInput {
  content: String!
  conversationId: String!
  senderId: String!
}

input SignUpInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  phoneNumber: String!
}

input SubmitApplicationInput {
  applicantDetails: ApplicantDetailsInput!
  documents: ApplicationDocumentsInput
  employment: EmploymentDetailsInput
  propertyId: ID!
  references: [ReferenceInput!]
}

input UpdateApplicationInput {
  applicantDetails: ApplicantDetailsInput
  documents: ApplicationDocumentsInput
  employment: EmploymentDetailsInput
  references: [ReferenceInput!]
}

input UpdatePropertyInput {
  address: AddressInput
  amenities: [String!]
  availability: PropertyAvailabilityInput
  description: String
  media: PropertyMediaInput
  pricing: PropertyPricingInput
  propertyType: PropertyType
  specifications: PropertySpecificationsInput
  status: PropertyStatus
  title: String
}

input UpdateUserInput {
  firstName: String
  lastName: String
  phoneNumber: String
  preferences: AWSJSON
  profileImage: String
}
