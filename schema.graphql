# AppSync-Safe GraphQL Schema for Nest Tanzania Rental Platform
# This is the ONLY schema file that should be consumed by CDK/AppSync
# ⚠️  DO NOT EDIT - Generated from modular schema files

type PropertyCard {
  propertyId: ID!
  title: String!
  monthlyRent: Float!
  currency: String!
  propertyType: PropertyType!
  bedrooms: Int
  district: String!
  region: String!
  thumbnail: String
  available: Boolean!
  category: PropertyCategory
}

type PropertyCardsResponse {
  properties: [PropertyCard!]!
  nextToken: String
  count: Int!
}

type UserBasic {
  userId: ID!
  firstName: String!
  lastName: String!
  email: String!
  userType: UserType!
  profileImage: String
  language: String!
  currency: String!
}

type PersonalizedSections {
  favorites: [PropertyCard!]
  recentlyViewed: [PropertyCard!]
  recommended: [PropertyCard!]
}

type AppInitialState {
  categorizedProperties: CategorizedPropertiesResponse!
  totalProperties: Int!
}

type Query {
  getAppInitialState(limitPerCategory: Int = 10, userId: ID): AppInitialState!
  getPropertyCards(limit: Int = 20, nextToken: String): PropertyCardsResponse!
  getApplication(applicationId: ID!): Application
  listMyApplications(status: ApplicationStatus, limit: Int, nextToken: String): ApplicationListResponse!
  listPropertyApplications(propertyId: ID!, status: ApplicationStatus, limit: Int, nextToken: String): ApplicationListResponse!
  getApplicationStats(landlordId: ID!): ApplicationStats!
  getApplicationDocumentUploadUrl(applicationId: ID!, fileName: String!, fileType: String!): MediaUploadResponse!
  getUserConversations(userId: String!): [Conversation!]!
  getConversationMessages(conversationId: String!): [ChatMessage!]!
  getUnreadCount(userId: String!): Int!
  getRegions: [Region!]!
  getDistricts(regionId: ID!): [District!]!
  getWards(districtId: ID!): [Ward!]!
  getStreets(wardId: ID!): [Street!]!
  getMediaLibrary(userId: ID!): MediaItem
  getProperty(propertyId: ID!, userId: ID): Property
  listProperties(limit: Int, nextToken: String): PropertyListResponse!
  searchProperties(region: String, district: String, minPrice: Float, maxPrice: Float, propertyType: PropertyType, bedrooms: Int, limit: Int, from: Int, q: String): PropertySearchResponse!
  getPropertiesByLocation(region: String!, district: String): [Property!]!
  getNearbyProperties(lat: Float!, lng: Float!, radiusKm: Float): [Property!]!
  listLandlordProperties(landlordId: ID!, limit: Int, nextToken: String): PropertyListResponse!
  listManagedProperties(managerId: ID!, limit: Int, nextToken: String): PropertyListResponse!
  getCategorizedProperties(userId: ID, limitPerCategory: Int = 10): CategorizedPropertiesResponse!
  getPropertiesByCategory(category: PropertyCategory!, limit: Int = 20, nextToken: String, userId: ID): CategoryPropertyResponse!
  dummyQuery: String
  getUser(userId: ID!): UserProfile
  listUsers(limit: Int, nextToken: String): UserListResponse!
  listAllApplications(limit: Int, nextToken: String, status: ApplicationStatus): ApplicationListResponse!
}

input CognitoUserPool {
  userPoolId: String!
}

enum UserType {
  TENANT
  LANDLORD
  ADMIN
}

enum AccountStatus {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
  PENDING_LANDLORD_VERIFICATION
}

enum LocationType {
  REGION
  DISTRICT
  WARD
  STREET
}

enum PropertyType {
  APARTMENT
  HOUSE
  STUDIO
  ROOM
  COMMERCIAL
  LAND
}

enum PropertyStatus {
  DRAFT
  AVAILABLE
  RENTED
  MAINTENANCE
  DELETED
}

enum ApplicationStatus {
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  WITHDRAWN
  EXPIRED
}

enum EmploymentStatus {
  EMPLOYED_FULL_TIME
  EMPLOYED_PART_TIME
  SELF_EMPLOYED
  CONTRACT
  UNEMPLOYED
  STUDENT
  RETIRED
}

enum SmokingStatus {
  NON_SMOKER
  SMOKER
  OCCASIONAL
}

enum PropertyEventType {
  PRICE_CHANGED
  STATUS_CHANGED
  AVAILABILITY_CHANGED
  MEDIA_UPDATED
  DESCRIPTION_UPDATED
  PROPERTY_CREATED
}

input AddressInput {
  street: String!
  ward: String!
  district: String!
  region: String!
  postalCode: String
  coordinates: CoordinatesInput
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

input SubmitApplicationInput {
  propertyId: ID!
  applicantDetails: ApplicantDetailsInput!
}

input UpdateApplicationInput {
  applicantDetails: ApplicantDetailsInput
}

input UpdateApplicationStatusInput {
  status: ApplicationStatus!
  landlordNotes: String
  rejectionReason: String
}

input ApplicantDetailsInput {
  dateOfBirth: AWSDateTime!
  monthlyIncome: Float!
  occupation: String!
  moveInDate: AWSDateTime!
  leaseDuration: Int!
  numberOfOccupants: Int!
  hasPets: Boolean!
  petDetails: String
  smokingStatus: SmokingStatus!
  emergencyContact: EmergencyContactInput!
}

input EmergencyContactInput {
  name: String!
  relationship: String!
  phoneNumber: String!
  email: String
}

type Mutation {
  submitApplication(input: SubmitApplicationInput!): Application!
  updateApplication(applicationId: ID!, input: UpdateApplicationInput!): Application!
  updateApplicationStatus(applicationId: ID!, input: UpdateApplicationStatusInput!): Application!
  createConversation(input: CreateConversationInput!): Conversation!
  sendMessage(input: SendMessageInput!): ChatMessage!
  markAsRead(conversationId: String!, userId: String!): Conversation!
  publishNewMessage(input: AWSJSON!): PublishResult
  publishConversationUpdate(input: AWSJSON!): PublishResult
  publishUnreadCountUpdate(input: AWSJSON!): PublishResult
  createLocation(input: CreateLocationInput!): LocationCreateResponse!
  updateLocation(locationId: ID!, name: String!): LocationUpdateResponse!
  importLocationsFromCSV(csvData: String!): LocationImportResponse!
  regenerateLocationJson: LocationJsonResponse!
  getMediaUploadUrl(userId: ID!, fileName: String!, contentType: String!): MediaUploadResponse!
  deleteMediaItem(userId: ID!, fileUrl: String!): MediaItem
  associateMediaWithProperty(propertyId: ID!, landlordId: ID!, media: PropertyMediaInput!): Property!
  createProperty(landlordId: ID!, input: CreatePropertyInput!): Property!
  updateProperty(propertyId: ID!, landlordId: ID!, input: UpdatePropertyInput!): Property!
  deleteProperty(propertyId: ID!, landlordId: ID!): SuccessResponse!
  updatePropertyStatus(propertyId: ID!, landlordId: ID!, status: PropertyStatus!): Property!
  markPropertyAsRented(propertyId: ID!, landlordId: ID!, tenantId: ID!): Property!
  markPropertyAsAvailable(propertyId: ID!, landlordId: ID!): Property!
  assignPropertyManager(propertyId: ID!, landlordId: ID!, managerId: ID!): SuccessResponse!
  removePropertyManager(propertyId: ID!, landlordId: ID!): SuccessResponse!
  toggleFavorite(userId: ID!, propertyId: ID!): FavoriteResponse!
  importPropertiesFromCSV(csvData: String!): PropertyImportResult!
  publishNewPropertyEvent(propertyId: ID!, region: String!): SubscriptionPublishResponse
  publishPropertyUpdateEvent(input: PropertyUpdateEventInput!): PropertyUpdateEvent
  dummyMutation: String
  signUp(input: SignUpInput!): AuthResponse!
  signIn(email: String!, password: String!): AuthResponse!
  forgotPassword(email: String!): SuccessResponse!
  resetPassword(email: String!, confirmationCode: String!, newPassword: String!): SuccessResponse!
  verifyEmail(email: String!, code: String!): SuccessResponse!
  resendVerificationCode(email: String!): SuccessResponse!
  updateUser(userId: ID!, input: UpdateUserInput!): UserProfile!
  becomeLandlord(userId: ID!, input: BecomeLandlordInput!): ApplicationResponse!
  submitLandlordApplication(input: LandlordApplicationInput!): ApplicationResponse!
}

type Subscription {
  onApplicationStatusChanged(applicationId: ID!): Application
  onNewApplicationForLandlord(landlordId: ID!): Application
  onNewMessage(conversationId: String!): ChatMessage
  onConversationUpdated(userId: String!): Conversation
  onUnreadCountChanged(userId: String!): UnreadCountUpdate
  onPropertiesUpdated(propertyIds: [ID!]!): PropertyUpdateEvent
  onNewPropertyMatchesSearch(searchCriteria: PropertySearchInput!): Property
  onPropertyUpdated(propertyId: ID!): PropertyUpdateEvent
  onNewPropertyInRegion(region: String!): Property
  dummySubscription: String
}

type Application {
  applicationId: ID!
  propertyId: ID!
  property: Property
  applicantUserId: ID!
  applicant: Tenant
  landlordId: ID!
  landlord: Landlord
  status: ApplicationStatus!
  applicantDetails: ApplicantDetails!
  landlordNotes: String
  rejectionReason: String
  submittedAt: AWSDateTime!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ApplicantDetails {
  dateOfBirth: AWSDateTime!
  monthlyIncome: Float!
  occupation: String!
  moveInDate: AWSDateTime!
  leaseDuration: Int!
  numberOfOccupants: Int!
  hasPets: Boolean!
  petDetails: String
  smokingStatus: SmokingStatus!
  emergencyContact: EmergencyContact!
}

type EmergencyContact {
  name: String!
  relationship: String!
  phoneNumber: String!
  email: String
}

type ApplicationListResponse {
  applications: [Application!]!
  nextToken: String
  count: Int!
}

type ApplicationStats {
  total: Int!
  submitted: Int!
  underReview: Int!
  approved: Int!
  rejected: Int!
  withdrawn: Int!
}

input CreateConversationInput {
  tenantId: String!
  landlordId: String!
  propertyId: String!
  propertyTitle: String!
  initialMessage: String
}

input SendMessageInput {
  conversationId: String!
  senderId: String!
  content: String!
}

type UnreadCountUpdate {
  totalUnread: Int!
}

type PublishResult {
  success: Boolean!
  message: String
}

type ChatMessage {
  id: ID!
  conversationId: String!
  senderId: String!
  content: String!
  timestamp: String!
  isRead: Boolean!
}

type Conversation {
  id: String!
  tenantId: String!
  landlordId: String!
  propertyId: String!
  propertyTitle: String!
  lastMessage: String!
  lastMessageSender: String!
  lastMessageTime: String!
  unreadCount: AWSJSON!
  createdAt: String!
  updatedAt: String!
}

input CreateLocationInput {
  type: LocationType!
  name: String!
  parent: String
}

type LocationCreateResponse {
  success: Boolean!
  location: LocationResult!
  message: String!
}

union LocationResult = Region | District | Ward | Street

type LocationUpdateResponse {
  success: Boolean!
  message: String
  location: Region
}

type LocationImportResponse {
  success: Boolean!
  imported: Int!
  skipped: Int!
  errors: [String!]
  message: String!
}

type LocationJsonResponse {
  success: Boolean!
  cloudfrontUrl: String!
  message: String!
}

type Region {
  id: ID!
  name: String!
}

type District {
  id: ID!
  name: String!
  regionId: ID!
}

type Ward {
  id: ID!
  name: String!
  districtId: ID!
}

type Street {
  id: ID!
  name: String!
  wardId: ID!
}

type MediaItem {
  userId: String!
  actionTime: Float!
  media: PropertyMedia
  additionalFiles: [MediaFile]
}

type MediaUploadResponse {
  uploadUrl: String!
  key: String!
  fileUrl: String!
}

type MediaFile {
  contentType: String!
  fileUrl: String!
  fileName: String
}

input CreatePropertyInput {
  title: String!
  description: String!
  address: AddressInput!
  propertyType: PropertyType!
  specifications: PropertySpecificationsInput!
  pricing: PropertyPricingInput!
  amenities: [String!]
  media: PropertyMediaInput
  availability: PropertyAvailabilityInput!
}

input UpdatePropertyInput {
  title: String
  description: String
  address: AddressInput
  propertyType: PropertyType
  specifications: PropertySpecificationsInput
  pricing: PropertyPricingInput
  amenities: [String!]
  media: PropertyMediaInput
  availability: PropertyAvailabilityInput
  status: PropertyStatus
}

input PropertySpecificationsInput {
  squareMeters: Float!
  bedrooms: Int
  bathrooms: Int
  floors: Int
  parkingSpaces: Int
  furnished: Boolean
}

input PropertyPricingInput {
  monthlyRent: Float!
  deposit: Float!
  currency: String!
  utilitiesIncluded: Boolean
  serviceCharge: Float
}

input PropertyMediaInput {
  images: [String!]
  videos: [String!]
  virtualTour: String
  floorPlan: String
}

input PropertyAvailabilityInput {
  available: Boolean!
  availableFrom: AWSDateTime
  minimumLeaseTerm: Int
  maximumLeaseTerm: Int
}

input PropertyUpdateEventInput {
  propertyId: ID!
  eventType: PropertyEventType!
  changes: [PropertyChangeInput!]
  timestamp: AWSDateTime!
}

input PropertyChangeInput {
  field: String!
  oldValue: String
  newValue: String!
}

type SubscriptionPublishResponse {
  success: Boolean!
  message: String
  propertyId: ID
}

type Property {
  propertyId: ID!
  landlordId: ID!
  managerId: ID
  title: String!
  description: String!
  address: Address!
  propertyType: PropertyType!
  specifications: PropertySpecifications!
  pricing: PropertyPricing!
  amenities: [String!]
  media: PropertyMedia
  availability: PropertyAvailability!
  status: PropertyStatus!
  version: Int
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Address {
  street: String!
  ward: String!
  district: String!
  region: String!
  postalCode: String
  coordinates: Coordinates
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

type PropertySpecifications {
  squareMeters: Float!
  bedrooms: Int
  bathrooms: Int
  floors: Int
  parkingSpaces: Int
  furnished: Boolean
}

type PropertyPricing {
  monthlyRent: Float!
  deposit: Float!
  currency: String!
  utilitiesIncluded: Boolean
  serviceCharge: Float
}

type PropertyMedia {
  images: [String!]
  videos: [String!]
  virtualTour: String
  floorPlan: String
}

type PropertyAvailability {
  available: Boolean!
  availableFrom: AWSDateTime
  minimumLeaseTerm: Int
  maximumLeaseTerm: Int
}

type PropertyListResponse {
  properties: [Property!]!
  nextToken: String
  count: Int!
}

type PropertySearchResponse {
  properties: [Property!]!
  count: Int!
  total: Int!
  from: Int!
  size: Int!
  nextToken: String
}

type PropertyImportResult {
  success: Boolean!
  imported: Int!
  updated: Int!
  skipped: Int!
  errors: [String!]!
  message: String!
}

type FavoriteResponse {
  success: Boolean!
  isFavorited: Boolean!
  message: String
}

enum PropertyCategory {
  NEARBY
  LOWEST_PRICE
  FAVORITES
  MOST_VIEWED
  RECENTLY_VIEWED
  MORE
}

type CategoryPropertyResponse {
  properties: [PropertyCard!]!
  nextToken: String
  count: Int!
  category: PropertyCategory!
}

type CategorizedPropertiesResponse {
  nearby: CategoryPropertyResponse!
  lowestPrice: CategoryPropertyResponse!
  favorites: CategoryPropertyResponse
  mostViewed: CategoryPropertyResponse!
  recentlyViewed: CategoryPropertyResponse
  more: CategoryPropertyResponse!
}

type PropertyUpdateEvent {
  propertyId: ID!
  eventType: PropertyEventType!
  property: Property
  changes: [PropertyChange!]
  timestamp: AWSDateTime!
}

type PropertyChange {
  field: String!
  oldValue: String
  newValue: String!
}

input PropertySearchInput {
  region: String
  district: String
  minPrice: Float
  maxPrice: Float
  propertyType: PropertyType
  bedrooms: Int
}

input SignUpInput {
  email: String!
  password: String!
  phoneNumber: String!
  firstName: String!
  lastName: String!
}

input UpdateUserInput {
  firstName: String
  lastName: String
  phoneNumber: String
  profileImage: String
  preferences: AWSJSON
}

input BecomeLandlordInput {
  businessName: String!
  businessLicense: String!
  taxId: String!
  verificationDocuments: [String!]
}

input LandlordApplicationInput {
  userId: ID!
  nationalId: String!
  birthDate: String!
  phoneNumber: String!
  alternatePhone: String
  address: AddressInput!
}

type Tenant {
  userId: ID!
  email: String!
  phoneNumber: String
  firstName: String!
  lastName: String!
  userType: UserType!
  accountStatus: AccountStatus
  isEmailVerified: Boolean
  profileImage: String
  language: String
  currency: String
  emailNotifications: Boolean
  smsNotifications: Boolean
  pushNotifications: Boolean
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Landlord {
  userId: ID!
  email: String!
  phoneNumber: String
  firstName: String!
  lastName: String!
  userType: UserType!
  accountStatus: AccountStatus
  isEmailVerified: Boolean
  profileImage: String
  language: String
  currency: String
  emailNotifications: Boolean
  smsNotifications: Boolean
  pushNotifications: Boolean
  businessName: String
  businessLicense: String
  taxId: String
  verificationDocuments: [String!]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Admin {
  userId: ID!
  email: String!
  phoneNumber: String
  firstName: String!
  lastName: String!
  userType: UserType!
  accountStatus: AccountStatus
  isEmailVerified: Boolean
  profileImage: String
  language: String
  currency: String
  emailNotifications: Boolean
  smsNotifications: Boolean
  pushNotifications: Boolean
  permissions: [String!]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

union UserProfile = Tenant | Landlord | Admin

type AuthResponse {
  accessToken: String!
  refreshToken: String!
  user: UserProfile!
}

type SuccessResponse {
  success: Boolean!
  message: String!
}

type ApplicationResponse {
  success: Boolean!
  message: String!
  applicationId: ID
  status: String
  submittedAt: String
}

type UserListResponse {
  users: [UserProfile!]!
  nextToken: String
  count: Int!
}